name: Live Server

run-name: "Live Server - Full GitOps Demo"

on:
  push:
    branches: [main]
    paths:
      - 'app/ml-inference/**'
      - 'k8s/**'
      - 'scripts/dashboard_server.py'
  workflow_dispatch:
    inputs:
      duration_hours:
        description: 'How long to run (max 5.5 hours)'
        required: false
        default: '5.5'
      auto_restart:
        description: 'Auto-restart before timeout'
        required: false
        default: 'true'
        type: boolean
      ml_api_url:
        description: 'ML API public URL for metrics scraping'
        required: false
        default: ''
  repository_dispatch:
    types: [restart-live-server]

concurrency:
  group: live-server
  cancel-in-progress: true

jobs:
  # Job 1: Main cluster with ArgoCD, ML inference, Dashboard
  host:
    runs-on: ubuntu-latest
    timeout-minutes: 350

    permissions:
      contents: read
      actions: write
      packages: read

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache cloudflared
        uses: actions/cache@v4
        id: cloudflared-cache
        with:
          path: /usr/local/bin/cloudflared
          key: cloudflared-linux-amd64-v1

      - name: Install dependencies
        run: pip install flask flask-cors

      - name: Install cloudflared
        if: steps.cloudflared-cache.outputs.cache-hit != 'true'
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Start Minikube
        run: |
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          minikube start --cpus=2 --memory=4096 --kubernetes-version=v1.28.0
          kubectl cluster-info

      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          echo "Waiting for ArgoCD deployments..."
          sleep 10
          kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=available deployment/argocd-repo-server -n argocd --timeout=300s

          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "ArgoCD Password: $ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Build ML Inference Image
        run: |
          eval $(minikube docker-env)
          docker build -t ml-inference:latest app/ml-inference/
          docker tag ml-inference:latest ghcr.io/${{ github.repository_owner }}/ml-inference:latest
          echo "Image built successfully"

      - name: Deploy ML Inference
        run: |
          kubectl create namespace ml-inference || true

          kubectl port-forward svc/argocd-server -n argocd 8443:443 &
          sleep 5
          argocd login localhost:8443 --username admin --password $ARGOCD_PASSWORD --insecure

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }} \
            --path k8s/inference-service \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --auto-prune \
            --self-heal

          echo "Waiting for sync..."
          sleep 30
          argocd app list || true
          pkill -f "port-forward.*8443" || true

      - name: Run services with tunnel
        continue-on-error: true
        run: |
          set -e

          cleanup() {
            echo "=== Shutting down ==="
            pkill -f cloudflared || true
            pkill -f "kubectl port-forward" || true
            pkill -f dashboard_server || true
            minikube stop || true
            exit 0
          }
          trap cleanup SIGTERM SIGINT

          # Port forwards
          kubectl port-forward svc/argocd-server -n argocd 8443:443 --address 0.0.0.0 2>&1 | tee /tmp/argocd-pf.log &
          kubectl port-forward svc/ml-inference -n ml-inference 8000:80 --address 0.0.0.0 2>&1 | tee /tmp/api-pf.log &
          sleep 5

          # Dashboard
          python scripts/dashboard_server.py 2>&1 | tee /tmp/dashboard.log &
          sleep 3

          # Tunnel
          cloudflared tunnel --no-autoupdate run --token ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }} 2>&1 | tee /tmp/tunnel.log &
          sleep 10

          HOURS="${{ github.event.inputs.duration_hours || '5.5' }}"
          DURATION=$(echo "$HOURS * 3600" | bc | cut -d. -f1)
          RESTART_THRESHOLD=$((DURATION - 300))
          START_TIME=$(date +%s)
          RESTART_TRIGGERED=false

          echo ""
          echo "=========================================="
          echo "Host runner for $HOURS hours"
          echo "  - ArgoCD UI:  localhost:8443"
          echo "  - ML API:     localhost:8000"
          echo "  - Dashboard:  localhost:8080"
          echo ""
          echo "ArgoCD: admin / $ARGOCD_PASSWORD"
          echo "=========================================="

          while true; do
            ELAPSED=$(($(date +%s) - START_TIME))
            REMAINING=$((DURATION - ELAPSED))

            ARGOCD_OK=$(curl -sfk https://localhost:8443 > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            API_OK=$(curl -sf http://localhost:8000/health > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            DASHBOARD_OK=$(curl -sf http://localhost:8080 > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            TUNNEL_OK=$(pgrep -f cloudflared > /dev/null && echo "OK" || echo "DOWN")

            printf "[%s] ArgoCD: %s | API: %s | Dashboard: %s | Tunnel: %s | %dm/%dm\n" \
              "$(date '+%H:%M:%S')" "$ARGOCD_OK" "$API_OK" "$DASHBOARD_OK" "$TUNNEL_OK" \
              "$((ELAPSED/60))" "$((DURATION/60))"

            # Restart if down
            [ "$ARGOCD_OK" = "DOWN" ] && { pkill -f "port-forward.*argocd" || true; kubectl port-forward svc/argocd-server -n argocd 8443:443 --address 0.0.0.0 & sleep 3; }
            [ "$API_OK" = "DOWN" ] && { pkill -f "port-forward.*ml-inference" || true; kubectl port-forward svc/ml-inference -n ml-inference 8000:80 --address 0.0.0.0 & sleep 3; }
            [ "$DASHBOARD_OK" = "DOWN" ] && { pkill -f dashboard_server || true; python scripts/dashboard_server.py & sleep 3; }
            [ "$TUNNEL_OK" = "DOWN" ] && { cloudflared tunnel --no-autoupdate run --token ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }} & sleep 5; }

            # Auto-restart before timeout
            if [ "$ELAPSED" -gt "$RESTART_THRESHOLD" ] && [ "$RESTART_TRIGGERED" = "false" ]; then
              if [ "${{ github.event.inputs.auto_restart }}" = "true" ]; then
                curl -sX POST -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  https://api.github.com/repos/${{ github.repository }}/dispatches \
                  -d '{"event_type":"restart-live-server"}' || true
                RESTART_TRIGGERED=true
              fi
            fi

            [ "$ELAPSED" -gt "$DURATION" ] && break
            sleep 30
          done

          cleanup

      - name: Show logs on failure
        if: failure()
        run: |
          kubectl get pods -A
          cat /tmp/tunnel.log 2>/dev/null || true

  # Job 2: Standalone monitoring (parallel runner)
  monitoring:
    runs-on: ubuntu-latest
    timeout-minutes: 350

    steps:
      - name: Cache cloudflared
        uses: actions/cache@v4
        id: cloudflared-cache
        with:
          path: /usr/local/bin/cloudflared
          key: cloudflared-linux-amd64-v1

      - name: Install cloudflared
        if: steps.cloudflared-cache.outputs.cache-hit != 'true'
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Create VictoriaMetrics config
        run: |
          mkdir -p /tmp/vm-config
          cat > /tmp/vm-config/prometheus.yml << 'EOF'
          global:
            scrape_interval: 15s

          scrape_configs:
            - job_name: 'ml-inference'
              metrics_path: '/metrics'
              static_configs:
                - targets: ['${{ github.event.inputs.ml_api_url || 'localhost:8000' }}']
              scheme: https
              tls_config:
                insecure_skip_verify: true
          EOF

          echo "VictoriaMetrics config created"
          cat /tmp/vm-config/prometheus.yml

      - name: Run monitoring stack
        continue-on-error: true
        run: |
          set -e

          cleanup() {
            echo "=== Shutting down monitoring ==="
            docker stop victoriametrics grafana 2>/dev/null || true
            pkill -f cloudflared || true
            exit 0
          }
          trap cleanup SIGTERM SIGINT

          # Start VictoriaMetrics
          docker run -d --name victoriametrics \
            -p 8428:8428 \
            -v /tmp/vm-config:/etc/prometheus \
            victoriametrics/victoria-metrics:latest \
            -promscrape.config=/etc/prometheus/prometheus.yml

          # Start Grafana
          docker run -d --name grafana \
            -p 3000:3000 \
            -e GF_SECURITY_ADMIN_PASSWORD=admin \
            -e GF_AUTH_ANONYMOUS_ENABLED=true \
            grafana/grafana:latest

          sleep 10

          # Configure Grafana datasource
          curl -X POST http://localhost:3000/api/datasources \
            -H "Content-Type: application/json" \
            -u admin:admin \
            -d '{
              "name": "VictoriaMetrics",
              "type": "prometheus",
              "url": "http://172.17.0.1:8428",
              "access": "proxy",
              "isDefault": true
            }' || true

          # Start tunnel (requires CLOUDFLARE_TUNNEL_TOKEN_MONITORING secret)
          if [ -n "${{ secrets.CLOUDFLARE_TUNNEL_TOKEN_MONITORING }}" ]; then
            cloudflared tunnel --no-autoupdate run --token ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN_MONITORING }} 2>&1 | tee /tmp/tunnel.log &
          else
            echo "No monitoring tunnel token - services only accessible locally"
          fi

          sleep 5

          HOURS="${{ github.event.inputs.duration_hours || '5.5' }}"
          DURATION=$(echo "$HOURS * 3600" | bc | cut -d. -f1)
          START_TIME=$(date +%s)

          echo ""
          echo "=========================================="
          echo "Monitoring runner for $HOURS hours"
          echo "  - Grafana:        localhost:3000"
          echo "  - VictoriaMetrics: localhost:8428"
          echo ""
          echo "Grafana: admin / admin"
          echo "=========================================="

          while true; do
            ELAPSED=$(($(date +%s) - START_TIME))

            VM_OK=$(curl -sf http://localhost:8428/-/healthy > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            GRAFANA_OK=$(curl -sf http://localhost:3000/api/health > /dev/null 2>&1 && echo "OK" || echo "DOWN")

            printf "[%s] VictoriaMetrics: %s | Grafana: %s | %dm/%dm\n" \
              "$(date '+%H:%M:%S')" "$VM_OK" "$GRAFANA_OK" "$((ELAPSED/60))" "$((DURATION/60))"

            # Restart if down
            if [ "$VM_OK" = "DOWN" ]; then
              docker restart victoriametrics || docker start victoriametrics
              sleep 5
            fi

            if [ "$GRAFANA_OK" = "DOWN" ]; then
              docker restart grafana || docker start grafana
              sleep 5
            fi

            [ "$ELAPSED" -gt "$DURATION" ] && break
            sleep 30
          done

          cleanup

  notify:
    needs: [host, monitoring]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Session ended
        run: |
          echo "Host: ${{ needs.host.result }}"
          echo "Monitoring: ${{ needs.monitoring.result }}"
