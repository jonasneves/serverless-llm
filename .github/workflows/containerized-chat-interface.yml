name: Chat (Containerized)

run-name: Chat Interface (Container-based Architecture)

# Container-based architecture with auto-restart and multi-instance support
# Benefits:
# - Cloudflared runs in ultra-lightweight ubuntu:24.04 (~30MB) instead of full runner
# - Health monitoring isolated in separate container
# - Better resource isolation and management
# - Easier local development with docker-compose
# - Full auto-restart and multi-instance capabilities

on:
  workflow_dispatch:
    inputs:
      duration_hours:
        description: 'How long to run (max 5.5 hours)'
        required: false
        default: '5'
        type: string
      auto_restart:
        description: 'Auto-restart before timeout'
        required: false
        default: true
        type: boolean
      instances:
        description: 'Number of parallel instances (1-3)'
        required: false
        default: '1'
        type: choice
        options:
          - '1'
          - '2'
          - '3'

  repository_dispatch:
    types: [restart-chat-interface-containerized]

jobs:
  chat-containerized:
    name: Chat Interface (Containers) #${{ matrix.instance }}
    runs-on: ubuntu-slim
    timeout-minutes: 350
    permissions:
      actions: write
      contents: read
    strategy:
      matrix:
        instance: ${{ fromJson((github.event.client_payload.instances || github.event.inputs.instances || '1') == '3' && '[1,2,3]' || (github.event.client_payload.instances || github.event.inputs.instances || '1') == '2' && '[1,2]' || '[1]') }}
      fail-fast: false

    steps:
      - name: Find previous running workflow
        id: find_previous
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Current run ID: ${{ github.run_id }}"

          API_RESPONSE=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/containerized-chat-interface.yml/runs?status=in_progress")

          RUN_COUNT=$(echo "$API_RESPONSE" | jq '.total_count')
          echo "Total in_progress runs found: $RUN_COUNT"

          # Only consider strictly older runs to avoid cross-cancelling newer runs
          PREVIOUS_RUN_ID=$(echo "$API_RESPONSE" | jq -r ".workflow_runs[] | select(.id < ${{ github.run_id }}) | .id" | head -1)

          if [ -n "$PREVIOUS_RUN_ID" ] && [ "$PREVIOUS_RUN_ID" != "null" ] && [ "$PREVIOUS_RUN_ID" != "" ]; then
            echo "Found previous running workflow: $PREVIOUS_RUN_ID"
            echo "previous_run_id=$PREVIOUS_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "No previous running workflow found"
            echo "previous_run_id=" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build lightweight cloudflared image (~30MB) with caching
      - name: Build cloudflared sidecar
        uses: docker/build-push-action@v5
        with:
          context: ./docker/cloudflared
          tags: cloudflared:latest
          load: true
          cache-from: type=gha,scope=cloudflared
          cache-to: type=gha,mode=max,scope=cloudflared

      # Build health monitor sidecar (~30MB) with caching
      - name: Build health monitor sidecar
        uses: docker/build-push-action@v5
        with:
          context: ./docker/health-monitor
          tags: health-monitor:latest
          load: true
          cache-from: type=gha,scope=health-monitor
          cache-to: type=gha,mode=max,scope=health-monitor

      # Build main chat server with caching
      - name: Build chat server
        uses: docker/build-push-action@v5
        with:
          context: ./app/chat-interface
          tags: chat-server:latest
          load: true
          cache-from: type=gha,scope=chat-server
          cache-to: type=gha,mode=max,scope=chat-server

      # Show image sizes
      - name: Show image sizes
        run: |
          echo "Built images:"
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}" | grep -E "(cloudflared|health-monitor|chat-server)"

      # Create Docker network for service communication
      - name: Create Docker network
        run: docker network create chat-network

      # Start main chat server
      - name: Start chat server container
        env:
          PORT: "8080"
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
          QWEN_API_URL: ${{ secrets.QWEN_API_URL }}
          PHI_API_URL: ${{ secrets.PHI_API_URL }}
          LLAMA_API_URL: ${{ secrets.LLAMA_API_URL }}
          MISTRAL_API_URL: ${{ secrets.MISTRAL_API_URL }}
          GEMMA_API_URL: ${{ secrets.GEMMA_API_URL }}
          VIBEVOICE_API_URL: ${{ secrets.VIBEVOICE_API_URL }}
          GH_MODELS_TOKEN: ${{ secrets.GH_MODELS_TOKEN }}
        run: |
          docker run -d \
            --name chat-server \
            --network chat-network \
            -p 8080:8080 \
            -e PORT="$PORT" \
            -e BASE_DOMAIN="$BASE_DOMAIN" \
            -e QWEN_API_URL="$QWEN_API_URL" \
            -e PHI_API_URL="$PHI_API_URL" \
            -e LLAMA_API_URL="$LLAMA_API_URL" \
            -e MISTRAL_API_URL="$MISTRAL_API_URL" \
            -e GEMMA_API_URL="$GEMMA_API_URL" \
            -e VIBEVOICE_API_URL="$VIBEVOICE_API_URL" \
            -e GH_MODELS_TOKEN="$GH_MODELS_TOKEN" \
            chat-server:latest

          echo "Chat server container started"
          echo "Waiting for server to be ready..."
          sleep 10

          # Health check with better debugging
          HEALTHY=false
          for i in {1..15}; do
            echo "Health check attempt $i/15..."

            # Check if container is still running
            if ! docker ps | grep -q chat-server; then
              echo "ERROR: Container has stopped!"
              echo "Container logs:"
              docker logs chat-server
              exit 1
            fi

            # Try health endpoint
            RESPONSE=$(curl -s http://localhost:8080/health || echo "")
            if echo "$RESPONSE" | grep -q "healthy"; then
              echo "✓ Chat server is healthy!"
              echo "Response: $RESPONSE"
              HEALTHY=true
              break
            fi

            echo "Server not ready yet (attempt $i/15)"
            sleep 5
          done

          if [ "$HEALTHY" = "false" ]; then
            echo "ERROR: Server failed to become healthy after 75 seconds"
            echo ""
            echo "=== Container Status ==="
            docker ps -a | grep chat-server
            echo ""
            echo "=== Container Logs ==="
            docker logs chat-server
            exit 1
          fi

      # Start cloudflared in lightweight container
      # Note: Using --network host so cloudflared can access localhost:8080 (published from chat-server)
      - name: Start Cloudflare tunnel (lightweight sidecar)
        env:
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN_CHAT }}
        run: |
          if [ -n "$CLOUDFLARE_TUNNEL_TOKEN" ]; then
            docker run -d \
              --name chat-cloudflared \
              --network host \
              cloudflared:latest \
              tunnel --no-autoupdate run --token "$CLOUDFLARE_TUNNEL_TOKEN"

            echo "Cloudflared tunnel started in lightweight container"
            echo "Container size: ~30MB (vs ~120MB if bundled with Python)"
            echo "Using host network to access chat-server on localhost:8080"
            sleep 15

            echo ""
            echo "=== Checking tunnel logs ==="
            docker logs chat-cloudflared 2>&1 | head -30
          else
            echo "No tunnel token provided"
          fi

      # Start health monitor in lightweight container
      - name: Start health monitor (lightweight sidecar)
        run: |
          docker run -d \
            --name chat-health-monitor \
            --network chat-network \
            -e SERVER_URL=http://chat-server:8080/health \
            -e CHECK_INTERVAL=30 \
            -e TUNNEL_ENABLED=true \
            health-monitor:latest

          echo "Health monitor started in lightweight container"
          echo "Container size: ~30MB"

      # Show container stats
      - name: Show container architecture
        run: |
          echo "=========================================="
          echo "Container Architecture Summary"
          echo "=========================================="
          echo ""
          docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
          echo ""
          echo "Total containers: $(docker ps -q | wc -l)"
          echo ""
          echo "Image sizes:"
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}" | grep -E "(chat-server|cloudflared|health-monitor)"
          echo ""
          echo "Benefits:"
          echo "✓ Cloudflared isolated in ~30MB container (not bundled with Python)"
          echo "✓ Health monitor isolated in ~30MB container"
          echo "✓ Better resource management and isolation"
          echo "✓ Same docker-compose setup works locally and in production"

      # Graceful handoff: Cancel previous workflow now that new instance is ready
      - name: Cancel previous workflow (graceful handoff)
        if: steps.find_previous.outputs.previous_run_id != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PREVIOUS_RUN_ID: ${{ steps.find_previous.outputs.previous_run_id }}
        run: |
          echo "New server is ready, cancelling previous workflow run: $PREVIOUS_RUN_ID"

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$PREVIOUS_RUN_ID/cancel")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)

          if [ "$HTTP_CODE" = "202" ]; then
            echo ""
            echo "=========================================="
            echo "✓ Previous workflow cancellation accepted"
            echo "=========================================="
            echo ""
            echo "Waiting 3 minutes for graceful handoff..."
            for i in {1..18}; do
              printf "  Handoff wait: %d/180 seconds...\r" "$((i * 10))"
              sleep 10
            done
            echo ""
            echo "Handoff complete. This instance is now primary."
          else
            echo "⚠ Cancel request returned code $HTTP_CODE"
            sleep 5
          fi

      # Monitoring loop with auto-restart support
      - name: Monitor services
        env:
          DURATION_HOURS: ${{ github.event.client_payload.duration_hours || inputs.duration_hours || '5' }}
          AUTO_RESTART: ${{ github.event.client_payload.auto_restart != false && (inputs.auto_restart != false) }}
          INSTANCES: ${{ github.event.client_payload.instances || inputs.instances || '1' }}
        run: |
          set -e

          cleanup() {
            echo ""
            echo "=== Shutting down containers ==="
            docker stop chat-server chat-cloudflared chat-health-monitor 2>/dev/null || true
            docker rm chat-server chat-cloudflared chat-health-monitor 2>/dev/null || true
            docker network rm chat-network 2>/dev/null || true
            exit 0
          }
          trap cleanup SIGTERM SIGINT

          DURATION_SECONDS=$((DURATION_HOURS * 3600))
          RESTART_BUFFER=360  # 6 minutes before end (3 min handoff + 3 min buffer)
          RESTART_THRESHOLD=$((DURATION_SECONDS - RESTART_BUFFER))
          START_TIME=$(date +%s)
          END_TIME=$((START_TIME + DURATION_SECONDS))

          echo ""
          echo "=========================================="
          echo "=== Chat Interface Server (Containerized) ==="
          echo "Duration: ${DURATION_HOURS} hours"
          echo "Will run until: $(date -d @$END_TIME)"
          echo "Auto-restart: $AUTO_RESTART"
          echo "Instances: $INSTANCES"
          echo "=========================================="
          echo ""

          RESTART_TRIGGERED=false
          LOOP_COUNT=0

          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            REMAINING=$((END_TIME - CURRENT_TIME))
            LOOP_COUNT=$((LOOP_COUNT + 1))

            # Check container health
            CHAT_STATUS=$(docker inspect -f '{{.State.Status}}' chat-server 2>/dev/null || echo "stopped")
            TUNNEL_STATUS=$(docker inspect -f '{{.State.Status}}' chat-cloudflared 2>/dev/null || echo "stopped")
            MONITOR_STATUS=$(docker inspect -f '{{.State.Status}}' chat-health-monitor 2>/dev/null || echo "stopped")

            printf "[%s] Chat: %s | Tunnel: %s | Monitor: %s | Elapsed: %dm | Remaining: %dm\n" \
              "$(date '+%H:%M:%S')" "$CHAT_STATUS" "$TUNNEL_STATUS" "$MONITOR_STATUS" \
              "$((ELAPSED/60))" "$((REMAINING/60))"

            # Show recent logs every 5 iterations
            if [ $((LOOP_COUNT % 5)) -eq 0 ]; then
              echo "--- Recent container logs ---"
              docker logs --tail 5 chat-cloudflared 2>/dev/null || true
              echo "-----------------------------"
            fi

            # Restart containers if needed
            if [ "$CHAT_STATUS" != "running" ]; then
              echo "Restarting chat server container..."
              docker start chat-server || true
              sleep 10
            fi

            if [ "$TUNNEL_STATUS" != "running" ]; then
              echo "Restarting tunnel container..."
              docker start chat-cloudflared || true
              sleep 5
            fi

            if [ "$MONITOR_STATUS" != "running" ]; then
              echo "Restarting monitor container..."
              docker start chat-health-monitor || true
              sleep 5
            fi

            # Check if we need to trigger restart (only once, and only from instance #1 to avoid multiple dispatches)
            if [ "$ELAPSED" -gt "$RESTART_THRESHOLD" ] && [ "$RESTART_TRIGGERED" = "false" ] && [ "${{ matrix.instance }}" = "1" ]; then
              echo ""
              echo "=== Restart threshold reached ==="
              echo "Elapsed: ${ELAPSED}s, Threshold: ${RESTART_THRESHOLD}s"
              echo "AUTO_RESTART value: '$AUTO_RESTART'"
              if [ "$AUTO_RESTART" = "true" ]; then
                echo ""
                echo "=========================================="
                echo "Triggering restart workflow..."
                echo "=========================================="

                PAT_TOKEN="${{ secrets.WORKFLOW_PAT }}"
                if [ -z "$PAT_TOKEN" ]; then
                  echo "ERROR: WORKFLOW_PAT secret is not set!"
                  echo ""
                  echo "To fix this:"
                  echo "1. Go to GitHub Settings > Developer settings > Personal access tokens"
                  echo "2. Create a new token (classic) with 'repo' scope"
                  echo "3. Go to your repository Settings > Secrets and variables > Actions"
                  echo "4. Add a new secret named WORKFLOW_PAT with the token value"
                  echo ""
                  echo "Runner will exit without auto-restart."
                  RESTART_TRIGGERED=true
                else
                  RESPONSE=$(curl -sX POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer $PAT_TOKEN" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    https://api.github.com/repos/${{ github.repository }}/dispatches \
                    -d "{\"event_type\":\"restart-chat-interface-containerized\",\"client_payload\":{\"duration_hours\":\"$DURATION_HOURS\",\"auto_restart\":$AUTO_RESTART,\"instances\":\"$INSTANCES\"}}" \
                    -w "\nHTTP_STATUS:%{http_code}" 2>&1)

                  HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
                  BODY=$(echo "$RESPONSE" | grep -v "HTTP_STATUS:")

                  echo "HTTP Status: $HTTP_CODE"
                  if [ -n "$BODY" ]; then
                    echo "Response body: $BODY"
                  fi

                  if [ "$HTTP_CODE" = "204" ]; then
                    echo ""
                    echo "SUCCESS: Restart triggered!"
                    echo "New runner will start shortly..."
                    echo ""
                    echo "Waiting 3 minutes to allow new runner to initialize..."
                    for i in {1..18}; do
                      printf "  Handoff wait: %d/180 seconds...\r" "$((i * 10))"
                      sleep 10
                    done
                    echo ""
                    echo "Handoff wait complete. New runner should be ready."
                  elif [ "$HTTP_CODE" = "401" ]; then
                    echo ""
                    echo "ERROR: Authentication failed (401)"
                    echo "Your WORKFLOW_PAT token may be expired or invalid."
                  elif [ "$HTTP_CODE" = "403" ]; then
                    echo ""
                    echo "ERROR: Permission denied (403)"
                    echo "Your WORKFLOW_PAT lacks required permissions."
                  else
                    echo ""
                    echo "ERROR: Failed to trigger restart (HTTP $HTTP_CODE)"
                  fi
                  RESTART_TRIGGERED=true
                fi
              else
                echo "AUTO_RESTART is not 'true' (value: '$AUTO_RESTART'), skipping restart trigger"
                RESTART_TRIGGERED=true
              fi
            fi

            # Check if duration reached
            if [ $CURRENT_TIME -ge $END_TIME ]; then
              echo "Duration reached, shutting down..."
              break
            fi

            sleep 30
          done

          cleanup

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== Chat Server Logs ==="
          docker logs chat-server 2>&1 | tail -100 || echo "No logs"
          echo ""
          echo "=== Tunnel Logs ==="
          docker logs chat-cloudflared 2>&1 | tail -50 || echo "No logs"
          echo ""
          echo "=== Health Monitor Logs ==="
          docker logs chat-health-monitor 2>&1 | tail -50 || echo "No logs"
