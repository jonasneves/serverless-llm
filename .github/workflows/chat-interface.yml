name: Chat

run-name: Chat Interface

on:
  workflow_dispatch:
    inputs:
      duration_hours:
        description: 'How long to run (max 5.5 hours)'
        required: false
        default: '5'
        type: string
      auto_restart:
        description: 'Auto-restart before timeout'
        required: false
        default: true
        type: boolean
      instances:
        description: 'Number of parallel instances (1-3)'
        required: false
        default: '1'
        type: choice
        options:
          - '1'
          - '2'
          - '3'

  repository_dispatch:
    types: [restart-chat-interface]

jobs:
  chat:
    name: Chat Interface Server #${{ matrix.instance }}
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 350
    permissions:
      actions: write
      contents: read
    strategy:
      matrix:
        instance: ${{ fromJson((github.event.inputs.instances || github.event.client_payload.instances) == '3' && '[1,2,3]' || (github.event.inputs.instances || github.event.client_payload.instances) == '2' && '[1,2]' || '[1]') }}
      fail-fast: false

    steps:
      - name: Find previous running workflow
        id: find_previous
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Current run ID: ${{ github.run_id }}"

          # Find other running instances of this workflow (excluding current run)
          API_RESPONSE=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/chat-interface.yml/runs?status=in_progress")

          echo "API Response (first 500 chars): ${API_RESPONSE:0:500}"

          # Get count of in_progress runs
          RUN_COUNT=$(echo "$API_RESPONSE" | jq '.total_count')
          echo "Total in_progress runs found: $RUN_COUNT"

          # List all running workflow IDs
          echo "All running workflow IDs:"
          echo "$API_RESPONSE" | jq -r '.workflow_runs[].id'

          # Find the previous run (not current)
          PREVIOUS_RUN_ID=$(echo "$API_RESPONSE" | jq -r ".workflow_runs[] | select(.id != ${{ github.run_id }}) | .id" | head -1)

          if [ -n "$PREVIOUS_RUN_ID" ] && [ "$PREVIOUS_RUN_ID" != "null" ] && [ "$PREVIOUS_RUN_ID" != "" ]; then
            echo "Found previous running workflow: $PREVIOUS_RUN_ID"
            echo "previous_run_id=$PREVIOUS_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "No previous running workflow found (this is the only instance)"
            echo "previous_run_id=" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'app/chat-interface/requirements.txt'

      - name: Install dependencies
        run: |
          pip install -r app/chat-interface/requirements.txt

      - name: Install cloudflared
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Start chat interface server
        env:
          PORT: "8080"
          BASE_DOMAIN: ${{ secrets.BASE_DOMAIN }}
          # Legacy: Individual URLs (used if BASE_DOMAIN not set)
          QWEN_API_URL: ${{ secrets.QWEN_API_URL }}
          PHI_API_URL: ${{ secrets.PHI_API_URL }}
          LLAMA_API_URL: ${{ secrets.LLAMA_API_URL }}
          MISTRAL_API_URL: ${{ secrets.MISTRAL_API_URL }}
          QWEN14B_API_URL: ${{ secrets.QWEN14B_API_URL }}
          GEMMA_API_URL: ${{ secrets.GEMMA_API_URL }}
          VIBEVOICE_API_URL: ${{ secrets.VIBEVOICE_API_URL }}
          GH_MODELS_TOKEN: ${{ secrets.GH_MODELS_TOKEN }}
        run: |
          cd app/chat-interface
          python chat_server.py 2>&1 | tee /tmp/chat_server.log &
          SERVER_PID=$!
          echo "Chat Server PID: $SERVER_PID"
          echo "Waiting for server to start..."
          sleep 10

          # Health check
          for i in {1..10}; do
            if curl -s http://localhost:8080/health | grep -q "healthy"; then
              echo "Chat interface is healthy!"
              break
            fi
            echo "Waiting for server... attempt $i"
            sleep 5
          done

          # Verify health
          curl -s http://localhost:8080/health || { echo "Server failed to start"; cat /tmp/chat_server.log; exit 1; }

      - name: Start Cloudflare Tunnel
        env:
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN_CHAT }}
        run: |
          if [ -n "$CLOUDFLARE_TUNNEL_TOKEN" ]; then
            cloudflared tunnel --no-autoupdate run --token "$CLOUDFLARE_TUNNEL_TOKEN" 2>&1 | tee /tmp/tunnel.log &
            TUNNEL_PID=$!
            echo "Tunnel PID: $TUNNEL_PID"
            echo "Cloudflare tunnel started"
            # Wait for tunnel to establish
            sleep 15

            # Show tunnel status
            echo "=== Tunnel Log (first 30 lines) ==="
            head -30 /tmp/tunnel.log || true
          else
            echo "No tunnel token provided, server only accessible locally"
          fi

      - name: Cancel previous workflow (graceful handoff)
        if: steps.find_previous.outputs.previous_run_id != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PREVIOUS_RUN_ID: ${{ steps.find_previous.outputs.previous_run_id }}
        run: |
          echo "New server is ready, cancelling previous workflow run: $PREVIOUS_RUN_ID"

          # Cancel the previous workflow run
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$PREVIOUS_RUN_ID/cancel")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)

          echo "Cancel API response code: $HTTP_CODE"
          echo "Cancel API response body: $BODY"

          if [ "$HTTP_CODE" = "202" ]; then
            echo ""
            echo "=========================================="
            echo "✓ Previous workflow cancellation accepted"
            echo "=========================================="
            echo ""
            echo "Waiting 3 minutes for graceful handoff..."
            echo "This ensures minimal downtime during transition."
            # Wait for graceful handoff
            for i in {1..18}; do
              printf "  Handoff wait: %d/180 seconds...\r" "$((i * 10))"
              sleep 10
            done
            echo ""
            echo "Handoff complete. This instance is now primary."
          else
            echo "⚠ Cancel request returned code $HTTP_CODE - previous workflow may have already ended"
            sleep 5
          fi

          # Verify the previous workflow is no longer running
          STATUS=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$PREVIOUS_RUN_ID" \
            | jq -r '.status')

          echo "Previous workflow status after cancellation: $STATUS"

      - name: Health monitoring loop
        env:
          DURATION_HOURS: ${{ inputs.duration_hours || '5' }}
          AUTO_RESTART: ${{ inputs.auto_restart == false && 'false' || 'true' }}
          INSTANCES: ${{ inputs.instances || '1' }}
          QWEN_API_URL: ${{ secrets.QWEN_API_URL }}
          PHI_API_URL: ${{ secrets.PHI_API_URL }}
          LLAMA_API_URL: ${{ secrets.LLAMA_API_URL }}
          MISTRAL_API_URL: ${{ secrets.MISTRAL_API_URL }}
          QWEN14B_API_URL: ${{ secrets.QWEN14B_API_URL }}
          GEMMA_API_URL: ${{ secrets.GEMMA_API_URL }}
        run: |
          set -e
          # Handle cancellation gracefully
          cleanup() {
            echo ""
            echo "=== Shutting down ==="
            pkill -f cloudflared || true
            pkill -f chat_server.py || true
            exit 0
          }
          trap cleanup SIGTERM SIGINT

          # Convert hours to seconds (handle integer hours)
          DURATION_SECONDS=$((DURATION_HOURS * 3600))
          RESTART_BUFFER=360  # 6 minutes before end (3 min handoff + 3 min buffer)
          # Trigger restart 6 minutes before timeout
          RESTART_THRESHOLD=$((DURATION_SECONDS - RESTART_BUFFER))

          START_TIME=$(date +%s)
          END_TIME=$((START_TIME + DURATION_SECONDS))

          echo ""
          echo "=========================================="
          echo "=== Chat Interface Server ==="
          echo "Server running on port 8080"
          echo "Duration: ${DURATION_HOURS} hours"
          echo "Will run until: $(date -d @$END_TIME)"
          echo "=========================================="
          echo ""
          echo "Model endpoints configured:"
          echo "  - Qwen 7B: ${QWEN_API_URL:-not configured}"
          echo "  - Qwen 14B: ${QWEN14B_API_URL:-not configured}"
          echo "  - Phi: ${PHI_API_URL:-not configured}"
          echo "  - Llama: ${LLAMA_API_URL:-not configured}"
          echo "  - Mistral: ${MISTRAL_API_URL:-not configured}"
          echo "  - Gemma: ${GEMMA_API_URL:-not configured}"
          echo ""

          RESTART_TRIGGERED=false
          LOOP_COUNT=0

          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            REMAINING=$((END_TIME - CURRENT_TIME))
            LOOP_COUNT=$((LOOP_COUNT + 1))

            # Health checks
            SERVER_OK=$(curl -sf http://localhost:8080/health > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            TUNNEL_OK=$(pgrep -f cloudflared > /dev/null && echo "OK" || echo "DOWN")

            printf "[%s] Chat Server: %s | Tunnel: %s | Elapsed: %dm | Remaining: %dm\n" \
              "$(date '+%H:%M:%S')" "$SERVER_OK" "$TUNNEL_OK" "$((ELAPSED/60))" "$((REMAINING/60))"

            # Show recent logs every 5 iterations
            if [ $((LOOP_COUNT % 5)) -eq 0 ]; then
              echo "--- Recent tunnel log ---"
              tail -5 /tmp/tunnel.log 2>/dev/null || true
              echo "--- Recent server log ---"
              tail -5 /tmp/chat_server.log 2>/dev/null || true
              echo "-------------------------"
            fi

            # Restart server if down
            if [ "$SERVER_OK" = "DOWN" ]; then
              echo "Restarting chat server..."
              pkill -f chat_server.py || true
              cd app/chat-interface
              python chat_server.py 2>&1 | tee -a /tmp/chat_server.log &
              sleep 10
            fi

            # Restart tunnel if down
            if [ "$TUNNEL_OK" = "DOWN" ]; then
              echo "Restarting Cloudflare tunnel..."
              cloudflared tunnel --no-autoupdate run --token ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN_CHAT }} 2>&1 | tee -a /tmp/tunnel.log &
              sleep 5
            fi

            # Check if we need to trigger restart (only once)
            # Check elapsed time first, then AUTO_RESTART inside (matches working pattern)
            if [ "$ELAPSED" -gt "$RESTART_THRESHOLD" ] && [ "$RESTART_TRIGGERED" = "false" ]; then
              echo ""
              echo "=== Restart threshold reached ==="
              echo "Elapsed: ${ELAPSED}s, Threshold: ${RESTART_THRESHOLD}s"
              echo "AUTO_RESTART value: '$AUTO_RESTART'"
              echo "AUTO_RESTART type check: $(echo "$AUTO_RESTART" | od -c | head -1)"
              if [ "$AUTO_RESTART" = "true" ]; then
                echo ""
                echo "=========================================="
                echo "Triggering restart workflow..."
                echo "Elapsed: ${ELAPSED}s, Threshold: ${RESTART_THRESHOLD}s"
                echo "AUTO_RESTART: $AUTO_RESTART"
                echo "=========================================="

                # Check if WORKFLOW_PAT is set
                PAT_TOKEN="${{ secrets.WORKFLOW_PAT }}"
                if [ -z "$PAT_TOKEN" ]; then
                  echo "ERROR: WORKFLOW_PAT secret is not set!"
                  echo ""
                  echo "To fix this:"
                  echo "1. Go to GitHub Settings > Developer settings > Personal access tokens"
                  echo "2. Create a new token (classic) with 'repo' scope"
                  echo "3. Go to your repository Settings > Secrets and variables > Actions"
                  echo "4. Add a new secret named WORKFLOW_PAT with the token value"
                  echo ""
                  echo "Runner will exit without auto-restart."
                  RESTART_TRIGGERED=true
                else
                  # Use PAT token for triggering (GITHUB_TOKEN cannot trigger workflows)
                  echo "Sending repository_dispatch event with instances=$INSTANCES..."
                  RESPONSE=$(curl -sX POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer $PAT_TOKEN" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    https://api.github.com/repos/${{ github.repository }}/dispatches \
                    -d "{\"event_type\":\"restart-chat-interface\",\"client_payload\":{\"instances\":\"$INSTANCES\"}}" \
                    -w "\nHTTP_STATUS:%{http_code}" 2>&1)

                  HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
                  BODY=$(echo "$RESPONSE" | grep -v "HTTP_STATUS:")

                  echo "HTTP Status: $HTTP_CODE"
                  if [ -n "$BODY" ]; then
                    echo "Response body: $BODY"
                  fi

                  if [ "$HTTP_CODE" = "204" ]; then
                    echo ""
                    echo "SUCCESS: Restart triggered!"
                    echo "New runner will start shortly..."
                    echo ""
                    echo "Waiting 3 minutes to allow new runner to initialize..."
                    echo "This ensures graceful handoff with minimal downtime."
                    # Wait for new runner to start
                    for i in {1..18}; do
                      printf "  Handoff wait: %d/180 seconds...\r" "$((i * 10))"
                      sleep 10
                    done
                    echo ""
                    echo "Handoff wait complete. New runner should be ready."
                  elif [ "$HTTP_CODE" = "401" ]; then
                    echo ""
                    echo "ERROR: Authentication failed (401)"
                    echo "Your WORKFLOW_PAT token may be expired or invalid."
                  elif [ "$HTTP_CODE" = "403" ]; then
                    echo ""
                    echo "ERROR: Permission denied (403)"
                    echo "Your WORKFLOW_PAT lacks required permissions."
                    echo "Required: Personal Access Token with 'repo' scope"
                  elif [ "$HTTP_CODE" = "404" ]; then
                    echo ""
                    echo "ERROR: Repository not found (404)"
                    echo "Your WORKFLOW_PAT may not have access to this repository."
                  else
                    echo ""
                    echo "ERROR: Failed to trigger restart (HTTP $HTTP_CODE)"
                  fi
                  RESTART_TRIGGERED=true
                fi
              else
                echo "AUTO_RESTART is not 'true' (value: '$AUTO_RESTART'), skipping restart trigger"
                RESTART_TRIGGERED=true
              fi
            fi

            # Check if hard timeout exceeded
            if [ $CURRENT_TIME -ge $END_TIME ]; then
              echo "Duration exceeded, shutting down..."
              break
            fi

            sleep 30
          done

          cleanup

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== Chat Server Log ==="
          cat /tmp/chat_server.log 2>/dev/null || echo "No server log"
          echo ""
          echo "=== Tunnel Log ==="
          cat /tmp/tunnel.log 2>/dev/null || echo "No tunnel log"
