name: Chat Interface

on:
  workflow_dispatch:
    inputs:
      duration_hours:
        description: 'How long to run (max 5.5 hours)'
        required: false
        default: '5'
        type: string
      auto_restart:
        description: 'Auto-restart before timeout'
        required: false
        default: true
        type: boolean
      qwen_api_url:
        description: 'Qwen API URL (Cloudflare tunnel URL)'
        required: false
        default: ''
        type: string
      phi_api_url:
        description: 'Phi API URL (Cloudflare tunnel URL)'
        required: false
        default: ''
        type: string
      llama_api_url:
        description: 'Llama API URL (Cloudflare tunnel URL)'
        required: false
        default: ''
        type: string

  repository_dispatch:
    types: [restart-chat-interface]

jobs:
  chat:
    name: Chat Interface Server
    runs-on: ubuntu-latest
    timeout-minutes: 350
    permissions:
      actions: write
      contents: read

    steps:
      - name: Find previous running workflow
        id: find_previous
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Current run ID: ${{ github.run_id }}"

          # Find other running instances of this workflow (excluding current run)
          API_RESPONSE=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/chat-interface.yml/runs?status=in_progress")

          echo "API Response (first 500 chars): ${API_RESPONSE:0:500}"

          # Get count of in_progress runs
          RUN_COUNT=$(echo "$API_RESPONSE" | jq '.total_count')
          echo "Total in_progress runs found: $RUN_COUNT"

          # List all running workflow IDs
          echo "All running workflow IDs:"
          echo "$API_RESPONSE" | jq -r '.workflow_runs[].id'

          # Find the previous run (not current)
          PREVIOUS_RUN_ID=$(echo "$API_RESPONSE" | jq -r ".workflow_runs[] | select(.id != ${{ github.run_id }}) | .id" | head -1)

          if [ -n "$PREVIOUS_RUN_ID" ] && [ "$PREVIOUS_RUN_ID" != "null" ] && [ "$PREVIOUS_RUN_ID" != "" ]; then
            echo "Found previous running workflow: $PREVIOUS_RUN_ID"
            echo "previous_run_id=$PREVIOUS_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "No previous running workflow found (this is the only instance)"
            echo "previous_run_id=" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'app/chat-interface/requirements.txt'

      - name: Install dependencies
        run: |
          pip install -r app/chat-interface/requirements.txt

      - name: Install cloudflared
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Start chat interface server
        env:
          PORT: "8080"
          QWEN_API_URL: ${{ inputs.qwen_api_url || secrets.QWEN_API_URL }}
          PHI_API_URL: ${{ inputs.phi_api_url || secrets.PHI_API_URL }}
          LLAMA_API_URL: ${{ inputs.llama_api_url || secrets.LLAMA_API_URL }}
          GITHUB_TOKEN: ${{ secrets.DISCUSSION_GITHUB_TOKEN }}
        run: |
          cd app/chat-interface
          python chat_server.py &
          echo "Waiting for server to start..."
          sleep 10

          # Health check
          for i in {1..10}; do
            if curl -s http://localhost:8080/health | grep -q "healthy"; then
              echo "Chat interface is healthy!"
              break
            fi
            echo "Waiting for server... attempt $i"
            sleep 5
          done

      - name: Start Cloudflare Tunnel
        env:
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN_CHAT }}
        run: |
          if [ -n "$CLOUDFLARE_TUNNEL_TOKEN" ]; then
            cloudflared tunnel --no-autoupdate run --token "$CLOUDFLARE_TUNNEL_TOKEN" &
            echo "Cloudflare tunnel started"
            # Wait for tunnel to establish
            sleep 15
          else
            echo "No tunnel token provided, server only accessible locally"
          fi

      - name: Cancel previous workflow (graceful handoff)
        if: steps.find_previous.outputs.previous_run_id != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PREVIOUS_RUN_ID: ${{ steps.find_previous.outputs.previous_run_id }}
        run: |
          echo "New server is ready, cancelling previous workflow run: $PREVIOUS_RUN_ID"

          # Cancel the previous workflow run
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$PREVIOUS_RUN_ID/cancel")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)

          echo "Cancel API response code: $HTTP_CODE"
          echo "Cancel API response body: $BODY"

          if [ "$HTTP_CODE" = "202" ]; then
            echo "✓ Previous workflow cancellation accepted. Traffic will now be served by this instance."
          else
            echo "⚠ Cancel request returned code $HTTP_CODE - previous workflow may have already ended"
          fi

          # Wait a moment for the cancellation to take effect
          sleep 5

          # Verify the previous workflow is no longer running
          STATUS=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$PREVIOUS_RUN_ID" \
            | jq -r '.status')

          echo "Previous workflow status after cancellation: $STATUS"

      - name: Health monitoring loop
        env:
          DURATION_HOURS: ${{ inputs.duration_hours || '5' }}
          AUTO_RESTART: ${{ inputs.auto_restart }}
          QWEN_API_URL: ${{ inputs.qwen_api_url || secrets.QWEN_API_URL }}
          PHI_API_URL: ${{ inputs.phi_api_url || secrets.PHI_API_URL }}
          LLAMA_API_URL: ${{ inputs.llama_api_url || secrets.LLAMA_API_URL }}
        run: |
          # Convert hours to seconds (handle integer hours)
          DURATION_SECONDS=$((DURATION_HOURS * 3600))
          RESTART_BUFFER=300  # 5 minutes before end

          END_TIME=$(($(date +%s) + DURATION_SECONDS))
          RESTART_TIME=$((END_TIME - RESTART_BUFFER))

          echo "=== Chat Interface Server ==="
          echo "Server running on port 8080"
          echo "Duration: ${DURATION_HOURS} hours"
          echo "Will run until: $(date -d @$END_TIME)"
          echo "=============================="
          echo ""
          echo "Model endpoints configured:"
          echo "  - Qwen: ${QWEN_API_URL:-not configured}"
          echo "  - Phi: ${PHI_API_URL:-not configured}"
          echo "  - Llama: ${LLAMA_API_URL:-not configured}"
          echo ""

          RESTART_TRIGGERED=false

          while true; do
            CURRENT_TIME=$(date +%s)

            # Check if we need to trigger restart (only once)
            if [ "$AUTO_RESTART" = "true" ] && [ "$RESTART_TRIGGERED" = "false" ] && [ $CURRENT_TIME -ge $RESTART_TIME ]; then
              echo "Approaching timeout, triggering restart..."
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/dispatches" \
                -d '{"event_type":"restart-chat-interface"}'
              RESTART_TRIGGERED=true
              echo "Restart triggered. Continuing to serve traffic until new instance is ready..."
              # Don't break - keep running until cancelled by new workflow or hard timeout
            fi

            # Check if hard timeout exceeded (only exit if restart was triggered and we've waited long enough)
            if [ $CURRENT_TIME -ge $END_TIME ]; then
              echo "Duration exceeded, shutting down..."
              break
            fi

            # Health check
            if curl -s http://localhost:8080/health | grep -q "healthy"; then
              echo "[$(date)] Chat interface healthy"
            else
              echo "[$(date)] Chat interface unhealthy, attempting restart..."
              pkill -f chat_server.py || true
              cd app/chat-interface
              python chat_server.py &
              sleep 10
            fi

            sleep 30
          done
